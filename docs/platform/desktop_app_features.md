# Desktop App 功能列表

**版本**: v1.0
**日期**: 2025-11-14
**状态**: 待讨论

---

## 目录

1. [基础功能](#1-基础功能)
2. [改进功能](#2-改进功能)
3. [待讨论问题](#3-待讨论问题)

---

## 1. 基础功能

基于现有实现，Desktop App 已具备的核心能力：

### 1.1 录制功能

**功能描述**:
- 用户通过 Desktop App 启动录制
- Chrome Extension 监听用户在浏览器中的操作
- 记录操作类型：`navigate`, `click`, `select`, `copy_action`, `scroll` 等
- 用户通过**选中元素并复制**的方式标注要抓取的数据字段

**用户流程**:
```
1. 用户在 Desktop App 点击"开始录制"
2. 用户在 Chrome 中正常操作（打开网页、点击、选中文本、复制）
3. Extension 实时捕获操作，发送到 App Backend
4. 用户点击"停止录制"
5. 操作数据保存为 user_operations.json
```

**数据格式** (参考 `tests/fixtures/test_data/coffee_allegro/fixtures/user_operations.json`):
```json
{
  "session_info": {
    "start_time": "2025-09-13T10:34:05.099163",
    "total_operations": 16
  },
  "task_metadata": {
    "task_description": "用户的任务描述",
    "user_query": "用户的查询",
    "session_id": "session_xxx"
  },
  "operations": [
    {
      "type": "select",
      "timestamp": "2025-09-13 10:33:08",
      "element": {
        "xpath": "//*[@id='product-title']",
        "tagName": "H1",
        "textContent": "商品名称"
      },
      "data": {
        "selectedText": "商品名称",
        "textLength": 10
      }
    },
    {
      "type": "copy_action",
      "element": {...},
      "data": {
        "copiedText": "商品名称"
      }
    }
  ]
}
```

**现有能力**:
- ✅ 录制控制界面（开始/停止）
- ✅ 用户通过选中+复制标注字段
- ✅ 保存到 user_operations.json

---

### 1.2 Workflow 生成

**功能描述**:
录制结束后，系统通过 Intent Builder 自动生成可执行的 Workflow

**生成流程**:
```
user_operations.json
  ↓
IntentExtractor: 提取用户意图（Intent）
  ↓
MetaFlowGenerator: 生成 MetaFlow（中间表示）
  ↓
WorkflowGenerator: 生成 Workflow YAML
  ↓
workflow.yaml
```

**用户可见内容**:
- ✅ Workflow 步骤列表
- 📝 待确认：是否展示 MetaFlow 流程图？

**Workflow 结构** (参考 `tests/fixtures/test_data/coffee_allegro/output/workflow.yaml`):
```yaml
steps:
  - id: "extract-product-urls"
    agent_type: "scraper_agent"
    description: "Extract coffee product URLs"
    inputs:
      target_path: "https://..."
      data_requirements:
        user_description: "Extract all coffee product URLs"
        output_format:
          url: "Product URL"
        sample_data:
          - url: "https://example.com/product1"
        xpath_hints:
          url: "//*[@id='search-results']/..."

  - id: "collect-product-details"
    agent_type: "foreach"
    source: "{{product_urls}}"
    steps:
      - id: "scrape-product-info"
        agent_type: "scraper_agent"
        ...
```

**现有能力**:
- ✅ 完整的 Intent Builder 流程
- ✅ 生成包含 scraper_agent, foreach, variable 等步骤的 Workflow
- ✅ 支持 data_requirements, xpath_hints, sample_data

---

### 1.3 Workflow 执行

**功能描述**:
用户点击"运行"后，BaseAgent 执行 Workflow，控制浏览器完成自动化任务

**执行流程**:
```
用户点击"运行" →
  App Backend 加载 workflow.yaml →
  BaseAgent 逐步执行 steps →
  调用 Browser-use 控制浏览器 →
  实时推送执行日志到前端 →
  完成后返回结果
```

**用户可见内容**:
- ✅ **浏览器窗口**: 用户能看到浏览器自动操作（可视化执行）
- ✅ **执行日志**: 实时显示每个步骤的状态和结果

**日志格式**（示例）:
```
✅ Step 1: 打开网页 (2s)
✅ Step 2: 提取商品 URL (5s) - 找到 25 个商品
⏳ Step 3: 抓取商品详情 (进行中...)
    - 已处理 10/25 个商品
⏸ Step 4: 保存数据
```

**现有能力**:
- ✅ BaseAgent 执行引擎
- ✅ Browser-use 浏览器控制
- ✅ 可视化执行（浏览器窗口可见）
- ✅ 执行日志（需确认前端是否实时展示）

---

### 1.4 结果展示

**功能描述**:
执行完成后，展示抓取的数据和执行摘要

**用户可见内容**:
- ✅ **数据预览**: 以表格形式展示抓取的数据
- ✅ **下载功能**: 用户可以下载数据（Excel/CSV/JSON）

**示例界面**:
```
┌─────────────────────────────────────┐
│  ✅ 执行成功！                        │
│                                      │
│  📊 抓取结果（共 25 条）:             │
│  ┌──────────────────────────────┐   │
│  │ 商品名称 | 价格 | 销量        │   │
│  │ ──────────────────────────   │   │
│  │ 商品A | ¥99 | 100            │   │
│  │ 商品B | ¥199 | 50            │   │
│  │ ...                          │   │
│  └──────────────────────────────┘   │
│                                      │
│  [📥 下载 Excel] [📥 下载 CSV]      │
└─────────────────────────────────────┘
```

**现有能力**:
- ✅ 数据预览（表格形式）
- ✅ 数据下载

---

### 1.5 Workflow 管理

**功能描述**:
用户可以查看、管理已创建的 Workflow

**用户可见内容**:
- ✅ Workflow 列表（显示名称、创建时间、最后执行时间）
- ✅ 启动/停止 Workflow
- 📝 待确认：是否有执行历史记录？

**示例界面**:
```
┌─────────────────────────────────────┐
│  我的工作流                           │
│                                      │
│  ┌──────────────────────────────┐   │
│  │ 📊 每日销售报表下载          │   │
│  │ 最后执行：2小时前             │   │
│  │ [▶️ 运行] [✏️ 编辑]          │   │
│  └──────────────────────────────┘   │
│                                      │
│  ┌──────────────────────────────┐   │
│  │ 🛒 批量抓取商品价格          │   │
│  │ 最后执行：昨天                │   │
│  │ [▶️ 运行] [✏️ 编辑]          │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

**现有能力**:
- ✅ Workflow 列表
- ✅ 启动/停止功能

---

### 1.6 快速启动（一键流程）⭐ 新增

**功能描述**:
用户从录制到执行的完整流程一气呵成，无需手动切换多个界面

**核心价值**:
- 实现"3 分钟录制，5 分钟解决问题"的产品承诺
- 降低用户认知负担，专注于任务本身

**完整流程**:
```
1. 用户点击"快速开始" →
2. 录制操作（选中字段并复制） →
3. 停止录制 →
4. 【自动】上传到 Cloud Backend →
5. 【自动】生成 MetaFlow →
6. 【自动】生成 Workflow →
7. 【自动展示】Workflow 步骤预览 →
8. 用户确认（可选：调整） →
9. 【自动】立即执行 Workflow →
10. 【实时展示】浏览器窗口 + 执行日志 →
11. 【完成】数据预览 + 下载
```

**与传统流程对比**:

| 步骤 | 传统流程 | 快速启动流程 |
|------|---------|-------------|
| 录制 | 手动开始/停止 | 手动开始/停止 |
| 上传 | 手动上传 | **自动上传** |
| 生成 | 手动触发生成 | **自动生成** |
| 预览 | 需要切换到 Workflow 列表 | **自动展示** |
| 执行 | 手动点击"运行" | **自动执行**（用户确认后） |

**用户界面设计**:

**步骤 1: 快速开始入口**
```
┌─────────────────────────────────────┐
│  Ami Desktop                │
│                                      │
│  🚀 快速开始                          │
│  3 分钟录制，5 分钟自动化             │
│  [开始录制]                          │
│                                      │
│  ────────────────                    │
│                                      │
│  📋 我的工作流                        │
│  ...                                 │
└─────────────────────────────────────┘
```

**步骤 2-6: 录制并生成（自动）**
```
┌─────────────────────────────────────┐
│  🔴 正在录制...                       │
│  [停止录制]                          │
└─────────────────────────────────────┘
        ↓ 用户点击停止
┌─────────────────────────────────────┐
│  ⚙️ 正在生成工作流...                │
│  ✅ 已上传录制数据                   │
│  ⏳ 正在分析意图...                  │
│  [进度 50%]                          │
└─────────────────────────────────────┘
```

**步骤 7-8: Workflow 预览**
```
┌─────────────────────────────────────┐
│  ✨ 工作流生成成功！                  │
│                                      │
│  📋 工作流：抓取商品信息              │
│                                      │
│  步骤预览：                           │
│  1. 提取商品 URL (scraper_agent)    │
│  2. 抓取商品详情 (foreach)           │
│     - 商品名称                       │
│     - 价格                           │
│     - 销量                           │
│  3. 保存数据 (storage_agent)        │
│                                      │
│  💬 需要调整吗？                     │
│  ┌──────────────────────────────┐   │
│  │ (例如："增加库存字段")        │   │
│  └──────────────────────────────┘   │
│                                      │
│  [立即运行] [保存后手动运行]         │
└─────────────────────────────────────┘
```

**步骤 9-11: 执行并展示结果**
（复用 1.3 和 1.4 的界面）

**关键设计点**:

1. **进度可见**:
   - 每个自动化步骤都有进度提示
   - 用户知道系统在做什么

2. **可干预**:
   - 在执行前可以调整 Workflow
   - 通过自然语言对话（见改进功能 2.2）

3. **可中断**:
   - 生成过程中可以取消
   - 执行过程中可以停止

4. **错误处理**:
   - 生成失败 → 显示错误原因 → 提供"重新录制"或"手动调整"选项
   - 执行失败 → 显示失败步骤 → 提供"调试"或"重新执行"选项

**API 需求**（新增）:
```
POST /api/quick-start/record
  - 开始录制会话

POST /api/quick-start/stop-and-generate
  - 停止录制
  - 自动上传
  - 自动生成 MetaFlow 和 Workflow
  - 返回 Workflow 预览

POST /api/quick-start/execute
  - 立即执行生成的 Workflow
```

**现有能力**:
- ✅ 所有底层能力都已具备（录制、生成、执行）
- ❌ 缺少自动化编排和流程控制
- ❌ 缺少统一的快速启动入口

---

## 2. 改进功能

基于我们的讨论，需要新增或改进的功能：

---

### 2.1 单步测试能力 ⭐ P0

**问题**:
- 当前无法单独测试某个 Step
- 调试时必须执行整个 Workflow，效率低
- 无法快速验证某个 Step 的修改

**需求描述**:
用户可以选择 Workflow 中的某个 Step，单独执行并查看结果

**用户流程**:
```
1. 用户在 Workflow 步骤列表中选择 "scrape-product-info"
2. 点击"测试此步骤"
3. 系统执行该步骤（浏览器处于正确状态）
4. 显示该步骤的输出结果（如抓取到的数据表格）
5. 用户查看结果：
   - ✅ 满意 → 测试下一步 or 保存
   - ❌ 不满意 → 调整此步骤 → 再次测试
```

**关键设计点**:
- **需要从产品接口到后端设计都支持**
- 单步测试时，浏览器状态如何管理？（见待讨论问题）

**API 需求**（新增）:
```
POST /api/workflow/test-step
{
  "workflow_id": "xxx",
  "step_id": "scrape-product-info",
  "resume_from_state": true  // 是否复用之前的浏览器状态
}
```

---

### 2.2 自然语言调整 Workflow ⭐ P0

**问题**:
- 当前无法通过对话调整 Workflow
- 用户只能重新录制或手动修改 YAML（不现实）

**需求描述**:
用户可以通过自然语言描述问题，让 LLM 调整 Workflow 或某个 Step

**使用场景**:
1. **查看 Workflow 时**: 用户发现缺少某个步骤
2. **单步测试后**: 用户发现数据抓取不准确

**用户流程**:
```
用户: "缺少库存字段"
系统: 调用 LLM 分析
  → 识别用户在说 "scrape-product-info" 这个 Step
  → 修改 data_requirements，添加 "stock" 字段
  → 重新生成该 Step 的配置
系统: "已添加库存字段到抓取列表，请重新测试"
用户: 点击"测试此步骤"，查看结果
```

**LLM 调用逻辑**:
```
输入:
  - 用户自然语言描述："缺少库存字段"
  - 当前 Workflow YAML
  - 当前正在查看的 Step ID（如果有）
  - 最近一次执行结果（如果有）

输出:
  - 修改后的 Workflow YAML
  - 或只修改某个 Step 的配置
```

**界面设计**:
```
┌─────────────────────────────────────┐
│  Workflow: 抓取商品信息              │
│                                      │
│  步骤列表:                            │
│  1. 提取商品 URL                     │
│  2. 抓取商品详情 ← [当前查看]        │
│  3. 保存数据                         │
│                                      │
│  💬 调整建议:                        │
│  ┌──────────────────────────────┐   │
│  │ 缺少库存字段                  │   │
│  └──────────────────────────────┘   │
│  [发送]                              │
│                                      │
│  系统: 已添加库存字段，请测试        │
│  [🧪 测试此步骤]                    │
└─────────────────────────────────────┘
```

**待讨论问题**:
- LLM 如何理解上下文（知道用户在说哪个 Step）？
- 调整后如何验证？（自动测试 vs 用户手动触发）

---

### 2.3 智能处理数据缺失 ⭐ P1

**问题**:
- 不同页面结构导致某些字段缺失
- 无法区分"页面本来就没数据" vs "脚本失效"
- 用户不知道会缺失数据

**需求描述**:
系统能自动判断数据缺失的原因，并采取相应策略

**用户期望**:
- 有数据就尽可能拿到
- 没数据不报错，继续执行

**处理策略**（待讨论实现）:
1. **检测页面结构变化**:
   - 对比当前页面与录制时的页面结构
   - 如果结构相似，说明是"页面无数据"
   - 如果结构差异大，说明是"脚本失效"

2. **多次重试**:
   - XPath 失效时，尝试相似元素
   - 或调用 LLM 重新定位元素

3. **标记字段缺失**:
   - 最终无法获取时，标记为 null
   - 在日志中记录："库存字段未找到（页面无此数据）"

**执行日志示例**:
```
✅ Step 2: 抓取商品详情
    - 商品名称: ✅ 已获取
    - 价格: ✅ 已获取
    - 库存: ⚠️ 未找到（页面无此数据）
```

**待讨论问题**:
- 如何判断"页面本来就没数据"？
  - 检测页面结构相似度？
  - 多次重试后仍找不到？

---

### 2.4 页面结构变化自动适配 ⭐ P1

**问题**:
- 网页改版导致 XPath 失效
- 元素位置、className 变化
- 脚本直接失败

**需求描述**:
XPath 失效时，系统能自动适配新的页面结构

**处理流程**:
```
执行 scraper step → XPath 失效 →
  → 尝试自动修复:
     1. 调用 LLM 分析当前页面
     2. 基于 sample_data 和 user_description 重新生成 XPath
     3. 测试新 XPath 是否有效
  → 修复成功 → 继续执行
  → 修复失败 → 通知用户 →
     → 用户自然语言描述 →
     → LLM 调整脚本 →
     → 继续执行
```

**LLM 修复逻辑**:
```
输入:
  - 当前页面 HTML
  - 原始 xpath_hints
  - sample_data（期望的数据格式）
  - user_description（字段描述）

输出:
  - 新的 XPath
  - 或返回 "无法找到匹配元素"
```

**用户通知**:
```
⚠️ 检测到页面结构变化
原始 XPath 失效: //*[@id='price']
已自动修复为: //div[@class='product-price']/span
✅ 继续执行
```

**待讨论问题**:
- 自动修复的触发时机？（每次失败都尝试 vs 用户手动触发）
- 修复策略优先级？（LLM vs 相似元素匹配）

---

### 2.5 暂停机制（验证码处理） ⭐ P1

**问题**:
- 遇到验证码时脚本直接失败
- 用户无法手动处理后继续

**需求描述**:
检测到验证码或其他需要人工介入的情况时，暂停执行而不是失败

**触发场景**:
1. **验证码**: 系统检测到验证码元素
2. **滑块验证**: 检测到滑块元素
3. **手动标记**: 用户在录制时标记"这一步可能需要人工处理"

**用户流程**:
```
执行到登录步骤 →
  → 系统检测到验证码 →
  → 暂停执行，保持浏览器窗口打开 →
  → 通知用户: "检测到验证码，请手动处理"
  → 用户输入验证码 →
  → 用户点击"继续" →
  → 系统继续执行后续步骤
```

**界面设计**:
```
┌─────────────────────────────────────┐
│  ⏸ 执行已暂停                        │
│                                      │
│  🔐 检测到验证码，请手动处理          │
│                                      │
│  [🌐 浏览器窗口保持打开]             │
│                                      │
│  [✅ 我已处理，继续执行]             │
│  [⏹ 停止执行]                       │
└─────────────────────────────────────┘
```

**步骤状态**:
- ⏸ **暂停**: 等待用户处理（区别于 ❌ 失败）

**待讨论问题**:
- 如何检测验证码？
  - 检测特定 DOM 元素（如 reCAPTCHA iframe）？
  - 检测 URL 变化（如跳转到验证页面）？
  - 用户手动标记？

---

### 2.6 智能滚动 ⭐ P2

**问题**:
- 用户滚动可能是为了定位元素，也可能是为了加载数据
- 生成脚本时不知道是否要保留滚动操作
- 保留具体像素容易过拟合

**需求描述**:
- 保留用户录制的滚动操作
- 记录滚动的**目标**（而不是具体像素）

**滚动类型**:
1. **定位滚动**: 滚动到某个元素可见（Browser-use 可能已支持）
2. **加载滚动**: 滚动到底部触发新数据加载（无限滚动）

**记录格式**（建议）:
```json
{
  "type": "scroll",
  "scroll_type": "to_element",  // or "to_bottom", "load_more"
  "target_element": {
    "xpath": "...",
    "description": "滚动到商品列表底部"
  }
}
```

**生成 Workflow 时**:
```yaml
- id: "scroll-to-load-more"
  agent_type: "browser_action"
  description: "Scroll to bottom to load more products"
  inputs:
    action: "scroll"
    target: "bottom"
    wait_for_new_content: true
```

**待讨论问题**:
- 如何判断"滚动导致了新数据加载"？
  - 监控 DOM 变化（滚动前后元素数量对比）？
  - 监控网络请求（是否有新的 API 调用）？
- 滚动目标如何定义？
  - "滚动到页面底部"？
  - "滚动到元素 X 可见"？
  - "滚动 N 次直到没有新数据"？

---

### 2.7 提升 Intent Builder 生成质量 ⭐ P2

**问题**:
Intent Builder 生成的 scraper agent step 描述太少，导致脚本质量不高

**当前生成示例** (见 workflow.yaml):
```yaml
data_requirements:
  user_description: "Extract coffee product details..."
  output_format:
    product_name: "Coffee product name"
    product_price: "Product price"
```

**改进目标**:
1. **更详细的字段描述**:
   - 基于 `selectedText` 和 `textContent` 生成
   - 如: `product_name: "Coffee product name (full title, including brand and weight)"`

2. **更准确的 xpath_hints**:
   - 提供多个备选路径
   - 如: 主路径 + 备选路径

3. **更丰富的 sample_data**:
   - 基于录制时复制的数据
   - 如: `product_price: "69,50 zł"` (包含货币符号)

**关键点**:
- 这是现有功能的**改进**，不是新功能
- 需要优化 `IntentExtractor` 和 `WorkflowGenerator` 的 Prompt
- 需要充分利用 `user_operations.json` 中的信息

---

## 3. 待讨论问题

### 3.1 单步测试相关

**问题 1: 浏览器状态管理**

单步测试时，浏览器应该从什么状态开始？

**方案对比**:

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| **A. 从头开始** | 状态干净，结果可靠 | 耗时长，浪费资源 | 首次测试 |
| **B. 复用状态** | 快速，适合迭代调试 | 状态可能不一致 | 连续测试 |
| **C. 混合方案** | 兼顾速度和可靠性 | 实现复杂 | 建议方案 |

**建议方案 C 细节**:
```
1. 首次测试某个 Step:
   - 从头执行到该 Step（执行前置步骤）
   - 保存浏览器状态

2. 再次测试同一个 Step:
   - 复用之前保存的浏览器状态
   - 快速验证修改

3. 提供"重置"按钮:
   - 用户可以选择"从头开始测试"
```

**问题**: 你认为哪个方案更合适？

方案 C

---

**问题 2: Step 依赖处理**

如果 Step 3 依赖 Step 2 的输出，单独测试 Step 3 时如何提供输入？

**方案对比**:

| 方案 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **A. 强制执行前置步骤** | 自动执行 Step 1 和 Step 2 | 状态真实 | 耗时长 |
| **B. 用户提供 Mock 数据** | 用户手动输入测试数据 | 灵活 | 用户负担重 |
| **C. 使用历史执行数据** | 使用上次执行的中间结果 | 快速 | 可能过期 |

**问题**: 你认为哪个方案更合适？还是有其他想法？

C 

---

### 3.2 自然语言调整相关

**问题 3: LLM 上下文理解**

用户说"缺少库存字段"，系统如何知道是在说哪个 Step？

**方案对比**:

| 方案 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **A. 基于界面上下文** | 用户在查看 Step 2 时说的，自动关联 | 准确 | 需要前端传递上下文 |
| **B. 用户明确指定** | 用户必须说"Step 2 缺少库存字段" | 明确无歧义 | 用户体验差 |
| **C. LLM 自动推断** | LLM 分析对话历史和 Workflow 结构 | 智能 | 可能推断错误 |

**建议方案**: A + C 混合
- 优先使用界面上下文（如用户正在查看哪个 Step）
- 上下文不明确时，LLM 分析整个 Workflow 推断

**问题**: 你同意这个方案吗？

C 

---

**问题 4: 调整范围确定**

用户说"多抓取一个库存字段"，系统应该：
- 只修改 scraper step？
- 还是可能影响整个 workflow（如需要新增 variable step 保存库存）？

**方案对比**:

| 方案 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **A. LLM 自动判断** | LLM 分析后决定影响范围 | 智能 | 可能判断错误 |
| **B. 询问用户** | 系统询问"是否要修改整个 Workflow" | 用户可控 | 增加交互步骤 |
| **C. 最小修改原则** | 优先只修改当前 Step，不够再扩展 | 保守、安全 | 可能需要多次调整 |

**问题**: 你倾向于哪个方案？
C 

---

### 3.3 数据缺失处理相关

**问题 5: 如何判断"页面本来就没数据"**

**场景**: XPath 找不到元素，可能是：
1. 页面本来就没这个字段（正常）
2. XPath 失效，页面结构变化（异常）

**方案对比**:

| 方案 | 判断依据 | 优点 | 缺点 |
|------|---------|------|------|
| **A. 页面结构相似度** | 对比当前页面与录制时的整体结构 | 较准确 | 计算复杂 |
| **B. 多次重试** | 尝试多种定位方式，仍找不到就认为无数据 | 简单 | 可能误判 |
| **C. 检测相似元素** | 查找是否有相似的元素（如同类商品有库存，此商品没有） | 智能 | 实现复杂 |
| **D. 用户确认** | 首次遇到缺失时询问用户 | 准确 | 用户负担重 |

**问题**: 你认为哪个方案更实用？

Claude Agent 会判断页面有没有这个数据的，或者说他会判断数据是否缺失。 我觉得核心问题是，假设这是一个结构性的缺失，很多页面都没有这个内容，不能每次都 claude agent 来判断啊


---

### 3.4 自动修复相关

**问题 6: 自动修复的触发时机**

**方案对比**:

| 方案 | 说明 | 优点 | 缺点 |
|------|------|------|------|
| **A. 每次失败都尝试** | XPath 失效立即调用 LLM 修复 | 自动化程度高 | 成本高、可能频繁调用 |
| **B. 用户手动触发** | 执行失败后，用户点击"尝试修复" | 成本可控 | 用户体验差 |
| **C. 失败 N 次后触发** | 如失败 3 次后自动尝试修复 | 兼顾成本和体验 | 需要定义"失败次数" |

**问题**: 你倾向于哪个方案？


这就是我想表达的，有些可能是脚本要更新，有些可能是页面本来就没有。 我觉得 C 吧

---

**问题 7: 自动修复的策略优先级**

XPath 失效时，应该先尝试哪种修复方式？

**可能的策略**:
1. **尝试相似元素**: 查找同类元素（如 `//h1[@class='title']` 失效，尝试 `//h2[@class='title']`）
2. **基于 textContent 定位**: 根据录制时的文本内容查找
3. **调用 LLM 重新生成**: 分析当前页面，生成新 XPath

**建议优先级**:
```
1. 尝试相似元素（快速、免费）
2. 基于 textContent 定位（快速、免费）
3. 调用 LLM（慢、成本高，但最智能）
```

**问题**: 你同意这个优先级吗？

scraper agent 的Claude Agent 自己判断原因和方案

---

### 3.5 滚动处理相关

**问题 8: 如何判断"滚动导致了新数据加载"**

**方案对比**:

| 方案 | 判断依据 | 优点 | 缺点 |
|------|---------|------|------|
| **A. 监控 DOM 变化** | 滚动前后对比元素数量 | 直接、准确 | 可能误判（如广告加载） |
| **B. 监控网络请求** | 检测是否有新的 API 调用 | 准确 | 实现复杂 |
| **C. 用户手动标记** | 录制时用户标记"这次滚动会加载数据" | 最准确 | 增加用户负担 |
| **D. 混合方案** | A + B，双重验证 | 准确 | 实现复杂 |

**问题**: 你认为哪个方案更可行？
AB 同时可以

---

**问题 9: 滚动目标如何定义**

**方案对比**:

| 方案 | 示例 | 优点 | 缺点 |
|------|------|------|------|
| **A. 具体像素** | "滚动 500px" | 精确 | 容易过拟合 |
| **B. 语义目标** | "滚动到页面底部" | 通用 | 可能不够精确 |
| **C. 元素目标** | "滚动到元素 X 可见" | 准确 | 依赖元素存在 |
| **D. 循环滚动** | "滚动直到没有新数据" | 智能 | 实现复杂 |

**建议**: 根据场景选择
- 定位元素 → 方案 C
- 加载数据 → 方案 D

**问题**: 你同意吗？

同意
---

---

## 4. 方案确定总结

基于讨论，以下方案已确定：

### ✅ 单步测试

**问题 1: 浏览器状态管理** → **方案 C（混合方案）**
- 首次测试：从头执行到该 Step，保存浏览器状态
- 再次测试：复用之前保存的状态，快速验证
- 提供"重置"按钮：用户可选择从头开始

**问题 2: Step 依赖处理** → **方案 C（使用历史执行数据）**
- 使用上次执行的中间结果作为输入
- 快速，适合迭代调试

---

### ✅ 自然语言调整

**问题 3: LLM 上下文理解** → **方案 C（LLM 自动推断）**
- LLM 分析对话历史和 Workflow 结构，自动推断用户意图

**问题 4: 调整范围确定** → **方案 C（最小修改原则）**
- 优先只修改当前 Step
- 不够再扩展到整个 Workflow

---

### ✅ 数据缺失和自动修复

**问题 5: 判断"页面本来就没数据"** → **需要增强方案**
- ✅ Claude Agent 会判断单次页面有没有数据
- ⚠️ **核心问题**: 结构性缺失（很多页面都没有）时，不能每次都调用 Claude Agent
- **解决方案**（新增需求）:
  ```
  1. 首次遇到字段缺失 → Claude Agent 判断原因
  2. 如果是"页面无此数据" → 记录到 Workflow 配置
     - 标记该字段为 optional（可选）
     - 后续执行时，直接跳过，不再调用 Claude Agent
  3. 如果是"XPath 失效" → 触发自动修复流程
  ```

**问题 6: 自动修复触发时机** → **方案 C（失败 N 次后触发）**
- 兼顾成本和体验
- 避免频繁调用 LLM

**问题 7: 修复策略优先级** → **Claude Agent 自己判断**
- scraper agent 的 Claude Agent 自己分析原因并决定修复方案
- 不需要预定义优先级

---

### ✅ 滚动处理

**问题 8: 判断"滚动导致新数据加载"** → **AB 同时（混合方案）**
- 监控 DOM 变化（滚动前后元素数量对比）
- 监控网络请求（是否有新的 API 调用）
- 双重验证，提高准确性

**问题 9: 滚动目标定义** → **根据场景选择**
- 定位元素 → 方案 C（"滚动到元素 X 可见"）
- 加载数据 → 方案 D（"滚动直到没有新数据"）

---

## 5. 新增需求点

基于讨论，识别出以下新需求：

### 🆕 需求 2.8: 字段可选性记录（解决结构性数据缺失）

**问题背景**:
- 某些字段在部分页面存在，部分页面不存在（如"库存"字段）
- 不能每次都调用 Claude Agent 判断，成本太高

**解决方案**:
```
1. 首次遇到字段缺失:
   → Claude Agent 判断 → "页面本身无此数据"
   → 系统记录: 该字段标记为 optional

2. Workflow 配置更新:
   data_requirements:
     output_format:
       product_name:
         type: "string"
         required: true
       stock:
         type: "string"
         required: false  # ← 标记为可选
         fallback_value: null

3. 后续执行:
   → 找不到 stock 字段 → 直接跳过，不调用 Claude Agent
   → 日志记录: "⚠️ stock 字段缺失（已知可选字段）"
```

**API 需求**:
```
POST /api/workflow/update-field-optional
{
  "workflow_id": "xxx",
  "step_id": "scrape-product-info",
  "field": "stock",
  "optional": true,
  "reason": "部分页面无此数据"
}
```

---

## 6. 下一步行动

### 6.1 立即行动（文档完善）

- [x] 整理基础功能清单
- [x] 整理改进功能清单
- [x] 确定待讨论问题的方案
- [x] 新增"快速启动"基础功能
- [x] 新增"字段可选性记录"改进功能

### 6.2 后续任务

**阶段 1: 技术方案设计**
1. 单步测试 API 设计
2. 自然语言调整 LLM Prompt 设计
3. 字段可选性记录的数据结构设计
4. 快速启动流程的后端编排设计

**阶段 2: 产品设计**
1. 快速启动界面设计
2. 单步测试界面设计
3. 自然语言对话界面设计
4. 执行日志实时展示设计

**阶段 3: 开发实施**
按优先级实施各项功能

---

## 7. 新增核心功能

基于产品迭代需求，新增以下两个核心功能：

---

### 7.1 录制数据管理 (Recordings Library) ⭐ 新增

**功能描述**:
用户可以查看和管理所有历史录制数据（`user_operations.json` 文件），作为生成 Workflow 的"素材库"

**核心价值**:
- 录制数据可复用，避免重复录制
- 清晰了解每次录制捕获了哪些操作和字段
- 从录制库快速生成 Workflow

**用户流程**:
```
1. 用户点击"录制库"进入管理页面
2. 查看所有录制历史列表
   - 录制名称、时间、操作数量
   - 标记的字段数量和示例
   - 使用状态（已用/未使用）
3. 点击某个录制查看详情
   - 操作时间线（所有操作的顺序展示）
   - 提取的字段列表和示例数据
   - 关联的 Workflow（如果已生成）
4. 从录制生成 Workflow
   - 点击"生成 Workflow"
   - 跳转到 Workflow 生成流程
5. 删除不需要的录制
```

**页面设计**:

**录制列表页面**:
```
┌─────────────────────────────────────────────┐
│ ← 返回        📹 录制库            🎬 新录制  │
├─────────────────────────────────────────────┤
│ 🔍 搜索...      [全部] [未使用] [已使用]    │
│                                              │
│ ┌─ 录制卡片 ─────────────────────────────┐ │
│ │ 📹 Google 搜索咖啡              [已使用]│ │
│ │ 2025-11-14 10:34 • 16操作 • 3字段      │ │
│ │                                         │ │
│ │ 任务: 打开Google，搜索coffee，查看结果 │ │
│ │                                         │ │
│ │ 标记字段: product_name, price, sales   │ │
│ │ 已生成 2 个 Workflow                   │ │
│ │                                         │ │
│ │ [👁️ 查看] [⚡ 生成] [🗑️ 删除]         │ │
│ └─────────────────────────────────────────┘ │
└─────────────────────────────────────────────┘
```

**录制详情页面**:
```
┌─────────────────────────────────────────────┐
│ ← 返回        录制详情                       │
├─────────────────────────────────────────────┤
│ 📹 Google 搜索咖啡                          │
│ Session: session_20251114_103405            │
│                                              │
│ ┌─ 基本信息 ─────────────────────────────┐ │
│ │ 时间: 2025-11-14 10:34:05              │ │
│ │ 操作数: 16                              │ │
│ │ 起始URL: https://www.google.com        │ │
│ └─────────────────────────────────────────┘ │
│                                              │
│ ┌─ 操作时间线 ───────────────────────────┐ │
│ │ 1. [10:34:08] navigate → google.com   │ │
│ │ 2. [10:34:12] click → 搜索框           │ │
│ │ 3. [10:34:15] input → "coffee"        │ │
│ │ 4. [10:34:18] select ⭐                │ │
│ │    → "Coffee A" (标记字段)             │ │
│ │ 5. [10:34:19] copy_action ⭐           │ │
│ │    → 字段: product_name                │ │
│ │ ...                                    │ │
│ └─────────────────────────────────────────┘ │
│                                              │
│ ┌─ 提取的字段 ───────────────────────────┐ │
│ │ • product_name (3次)                   │ │
│ │   示例: "Coffee A", "Coffee B"...      │ │
│ │ • price (2次)                          │ │
│ │   示例: "$99", "$199"                  │ │
│ │ • sales (1次)                          │ │
│ │   示例: "100"                          │ │
│ └─────────────────────────────────────────┘ │
│                                              │
│ ┌─ 关联 Workflow ────────────────────────┐ │
│ │ • 抓取咖啡商品信息 (2小时前)           │ │
│ │ • 咖啡价格监控 (昨天)                  │ │
│ └─────────────────────────────────────────┘ │
│                                              │
│ [⚡ 生成新 Workflow] [🗑️ 删除]            │
└─────────────────────────────────────────────┘
```

**现有能力**:
- ❌ 录制列表展示
- ❌ 录制详情查看
- ❌ 从录制生成 Workflow
- ❌ 删除录制

**API 需求**（新增）:
```
GET /api/recordings
  → 获取所有录制列表

GET /api/recordings/{session_id}
  → 获取录制详情

DELETE /api/recordings/{session_id}
  → 删除录制

POST /api/recordings/{session_id}/generate-workflow
  → 从录制生成 Workflow
```

---

### 7.2 对话式 Workflow 生成 ⭐ 新增

**功能描述**:
用户通过自然语言对话描述需求，AI 分析后生成 Workflow。可以引用已有的录制数据作为参考。

**核心价值**:
- 降低使用门槛，无需录制也能生成 Workflow
- AI 理解用户意图，自动设计最优方案
- 结合历史录制数据，提高生成质量

**用户流程**:

**场景 1: 纯对话生成**
```
1. 用户点击"AI 生成 Workflow"
2. 进入对话界面
3. 用户描述需求:
   用户: "我想每天早上自动下载销售报表"
4. AI 分析并询问细节:
   AI: "请问报表在哪个网站？需要登录吗？"
5. 用户补充信息:
   用户: "在公司内网，需要用我的账号登录"
6. AI 生成 Workflow 预览:
   AI: "我为你设计了这个 Workflow:
       1. 打开内网登录页
       2. 自动填写账号密码
       3. 进入报表页面
       4. 下载最新报表
       5. 保存到本地文件夹
       是否需要调整？"
7. 用户确认或调整:
   用户: "可以，但我希望保存到桌面"
8. AI 调整后生成最终 Workflow
```

**场景 2: 引用录制数据**
```
1. 用户进入对话界面
2. 用户描述需求:
   用户: "我想抓取亚马逊商品数据"
3. AI 检测到相关录制:
   AI: "我看到你之前录制过类似操作：
       📹 亚马逊商品数据采集 (2天前)
       要基于这个录制生成吗？"
4. 用户确认:
   用户: "是的，用那个"
5. AI 基于录制生成 Workflow:
   AI: "已根据你的录制生成 Workflow，
       包含以下字段: 商品名称、价格、评分
       是否需要添加其他字段？"
6. 用户调整:
   用户: "再加上库存信息"
7. AI 更新 Workflow
```

**场景 3: 录制库直接跳转**
```
录制库 → 选择录制 → 点击"生成 Workflow" →
  → 跳转到对话页面（录制数据已预加载）
  → AI: "要为这个录制生成什么样的 Workflow？"
  → 用户: "每天定时运行，并发邮件通知"
  → AI 生成带定时和通知功能的 Workflow
```

**页面设计**:
```
┌─────────────────────────────────────────────┐
│ ← 返回        💬 AI 生成 Workflow            │
├─────────────────────────────────────────────┤
│                                              │
│ ┌─ 对话区域 ─────────────────────────────┐ │
│ │                                         │ │
│ │ 🤖 你好！我可以帮你生成自动化工作流。   │ │
│ │    请描述你想做什么？                   │ │
│ │                                         │ │
│ │ 👤 我想每天自动下载销售报表             │ │
│ │                                         │ │
│ │ 🤖 好的！请问：                         │ │
│ │    1. 报表在哪个网站？                  │ │
│ │    2. 是否需要登录？                    │ │
│ │    3. 报表格式是什么？                  │ │
│ │                                         │ │
│ │ 👤 在公司内网，需要登录，Excel格式      │ │
│ │                                         │ │
│ │ 🤖 我为你设计了这个 Workflow:          │ │
│ │    ┌────────────────────────────────┐  │ │
│ │    │ 1. 打开内网登录页               │  │ │
│ │    │ 2. 自动填写账号密码             │  │ │
│ │    │ 3. 进入报表页面                 │  │ │
│ │    │ 4. 下载最新报表                 │  │ │
│ │    │ 5. 保存到本地                   │  │ │
│ │    └────────────────────────────────┘  │ │
│ │    [✅ 生成 Workflow] [📝 调整]        │ │
│ │                                         │ │
│ └─────────────────────────────────────────┘ │
│                                              │
│ ┌─ 输入框 ───────────────────────────────┐ │
│ │ 输入你的需求...                   [发送]│ │
│ └─────────────────────────────────────────┘ │
│                                              │
│ 💡 提示: 你可以上传录制数据或详细描述流程   │
└─────────────────────────────────────────────┘
```

**侧边栏 - 引用录制**:
```
┌─ 📹 可用录制 ───────────────┐
│ • Google 搜索咖啡           │
│   [引用到对话]              │
│                             │
│ • 亚马逊商品采集            │
│   [引用到对话]              │
│                             │
│ [📚 查看更多录制]           │
└─────────────────────────────┘
```

**现有能力**:
- ❌ 对话界面
- ❌ LLM 对话集成
- ❌ 录制数据引用
- ❌ Workflow 预览和生成

**API 需求**（新增）:
```
POST /api/ai/chat
  → LLM 对话接口
  Body: {
    message: string,
    context: {
      conversation_history: Message[],
      referenced_recordings?: string[],
      user_id: string
    }
  }

POST /api/ai/generate-workflow
  → 从对话生成 Workflow
  Body: {
    conversation_id: string,
    user_confirmation: boolean
  }
```

---

## 8. 功能关联图

**三种 Workflow 生成路径**:

```
路径 1: 快速启动 (现有)
   录制操作 → 自动生成 → 预览 → 执行

路径 2: 对话生成 (新增)
   描述需求 → AI 对话 → 生成 Workflow → 执行

路径 3: 录制库生成 (新增)
   录制库 → 选择录制 → 生成 Workflow → 执行

三者结合:
   对话生成 + 引用录制库 = 最灵活的生成方式
```

**页面关联**:
```
主页
├─ 快速启动 → QuickStartPage
│   └─ 录制 → 生成 → 执行
│
├─ 录制库 → RecordingsLibraryPage (新)
│   ├─ 查看录制详情
│   └─ 生成 Workflow
│       └─ 可选跳转到对话生成
│
├─ AI 生成 → ConversationalGenerationPage (新)
│   ├─ 纯对话生成
│   └─ 引用录制库数据
│
└─ 我的 Workflow → MyWorkflowsPage
    └─ 管理已生成的 Workflow
```

**数据流**:
```
录制操作 (user_operations.json)
   ↓
录制库 (管理和复用)
   ↓
Workflow 生成 (3种路径)
   ↓
Workflow 管理
   ↓
执行和结果
```

---

## 9. 更新后的优先级

**P0 (立即实施):**
1. ✅ 主页重构
2. ✅ 快速启动流程
3. ✅ 执行监控页面
4. ✅ 结果展示页面
5. **录制数据管理** (新)
6. **对话式 Workflow 生成** (新)

**P1 (重要):**
7. Workflow 详情页 + 单步测试
8. Workflow 管理页改进

**实施顺序建议**:
```
Phase 1 (已完成): 核心流程 UI
  → 主页、快速启动、执行监控、结果展示

Phase 2 (进行中): 数据管理和 AI 生成
  → 录制库管理
  → 对话式生成

Phase 3 (后续): 高级功能
  → 单步测试
  → Workflow 编辑
```

---

**文档状态**: 新增功能已添加，待实施
